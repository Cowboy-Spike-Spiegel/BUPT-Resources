# 【编译原理与技术】语法分析

[toc]



# 语法分析简介

语法分析是编译程序的核心工作

## 语法分析程序

<img src="https://s1.ax1x.com/2020/10/03/01R8bt.png" alt="01R8bt.png" style="zoom:50%;" />

- 输入：记号流/序列
- 工作依据：源语言语法规则
- 功能：记号中识别、组合成语法成分，语法检查
- 输出：分析树
- 错误处理

常用的**分析方法**：

- 自顶向下：从树根到叶子建立分析树

- 自底向上：从树叶到树根建立分析树

<img src="https://s1.ax1x.com/2020/10/03/01WCIf.png" alt="01WCIf.png" style="zoom:50%;" />

对输入符号串的扫描顺序：**自左向右**



## 语法错误的处理

难度：语言设计时未考虑错误处理

程序错误种类：

- 词法错误：标识符、关键字或算符拼写错误
- 语法错误：括号不匹配。**占大多数**
- 语义错误：算符作用于不相容的运算对象
- 逻辑错误：无穷递归调用

错误处理基本目标：

- 报告错误出现
- 恢复错误，以便诊断后面错误
- 不明显影响正确程序的处理效率

错误恢复策略：

- 紧急方式恢复：抛弃出错语法结构，简单且不会陷入死循环
- 短语级恢复：局部纠错，防止死循环
- 出错产生式：扩充文法，增加产生错误的产生式
- 全局纠错：代价大，实际不用



## 符号使用约定

终结符：次序靠前的小写字母、运算符、标点符号、数字、黑体串（如：id、if、then）

非终结符：次序靠前的大写字母、字母 S（代表文法开始符号）、小写的斜体符号串

文法符号（终结符或非终结符）：字母表后面的大写字母、

终结符串：字母表后面的小写字母

文法符号串：小写希腊字母

通常用产生式集合代替四元组描述文法



# 自顶向下分析方法

## 递归下降分析

从文法开始符号出发，建立最左推导序列，推出输入串。即对给定输入串，从对应开始符号的根结点出发，自顶向下建立分析树。

采用产生式 $A\to b$ 时无法匹配，进行**回溯**：

<img src="https://s1.ax1x.com/2020/10/03/03epgx.png" alt="03epgx.png" style="zoom:50%;" />

采用最左推导的原因：最左推导才能按扫描顺序匹配输入串。

实现：

- 文法的每个非终结符对应一个递归（回溯）过程
- 作为布尔过程，某个产生式与输入串匹配时，展开分析树并返回 true

困难和缺点：

- 左递归文法死循环
- 回溯
- 重复工作
- 效率低：穷尽所有可能



## 递归调用预测分析

确定的、不带回溯的递归下降分析法               

### 如何克服回溯

工作结果确信无疑的：让每个候选式的开始符号不同

### 对文法的要求

文法符号串 $\alpha$ 的首符集：
$$
FIRST(\alpha)=\{a|\alpha\Rightarrow^*a\beta,a\in V_T,\alpha,\beta\in(V_T\cup V_N)\}
$$
如果 $\alpha\Rightarrow^*\varepsilon$，则规定 $\varepsilon\in FIRST(\alpha)$。

通俗地讲就是 $\alpha$ 可以推出很多符号串，这些符号串的所有**开头终结符号的集合**

对文法的要求：

1. 文法不含左递归：$A\Rightarrow^*A\alpha$。

2. 对于文法的每个非终结符 $A$，有产生式：
   $$
   A\to\alpha_1|...|\alpha_n
   $$
   则：
   $$
   FIRST(\alpha_i)\cap FIRST(\alpha_j) \qquad (i\not=j)
   $$
   即：非终结符 $A$ 的所有候选式的首符集两两互不相交。
   
   

示例：有如下产生 PASCAL 类型子集的文法：

<img src="https://s1.ax1x.com/2020/10/04/0G6Wd0.png" alt="0G6Wd0.png" style="zoom:50%;" />

预测过程：

<img src="https://s1.ax1x.com/2020/10/04/0GcpSe.png" alt="0GcpSe.png" style="zoom:50%;" />

产生式：$A\to \varepsilon$

**缺席匹配**：当递归下降分析程序没有适当候选式时，可以用一个 $\varepsilon$-候选式，表示其它候选式可以缺席。如果此时没有 $\varepsilon-$ 候选式则发现了输入符号串的错误。



### 预测分析程序的构造

#### 预测分析程序的转换图

每个非终结符号有一张有向图。边的标记可以是终结符号，也可以是非终结符号

#### 从文法构造转换图

改写文法：消除左递归+提取左公因式

#### 消除左递归

![image-20211024135516430](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211024135516430.png)

#### 提取左公因式

提取左公因子是一种语法转换方法，作用是改写文法。
当一个文法的非终结符有多个相同前缀的候选式时，就需要进行提取左公因子。看一个文法G：

S→aAd | aBe
A→c
B→b
提取左公因子后的文法G’：
S→aS’
S→Ad | Be
A→c
B→b
作用是延迟选择，等得到足够多的输入信息后再决定选择哪一个候选式


对每个非终结符 $A$：

<img src="https://s1.ax1x.com/2020/10/11/0gKmWT.png" alt="0gKmWT.png" style="zoom:50%;" />

- 创建一个初态（是自己）和终态
- 对每个产生式 $A\to X_1\cdots X_n$ 创建一条从初态到终态的路径

#### 转换图的工作过程

状态 $S$ 有射出边到 $T$：

- 射出边标记为 $a$，则当前指针指向的输入为 $a$，指针前移，状态转移到 $T$：

  <img src="https://s1.ax1x.com/2020/10/11/0gnUN6.png" alt="0gnUN6.png" style="zoom:50%;" />

- 射出边标记为非终结符号 $A$，则对相应 $A$ 的过程的调用。转移到 $A$ 对应的状态转移图的初始状态，不移动指针，如果到了 $A$ 的终结状态，返回 $T$

  <img src="https://s1.ax1x.com/2020/10/11/0gnR4f.png" alt="0gnR4f.png" style="zoom:50%;" />

- 如果射出边标记为 $\varepsilon$，控制立即从状态 $S\to T$，指针不动

  <img src="https://s1.ax1x.com/2020/10/11/0gn7bn.png" alt="0gn7bn.png" style="zoom:50%;" />

#### 转换图的确定性

对每个状态的所有射出弧：

- 不存在同名弧
- 不存在 $\varepsilon-$ 弧
- 非终结符为标志的弧是唯一射出弧

非确定性的解决：

- 特殊方法
- 建立带回溯的系统



#### 转换图的化简

代入法：

<img src="https://s1.ax1x.com/2020/10/11/0gQMZ9.png" alt="0gQMZ9.png" style="zoom:70%;" />

把 $E’$ 的转换图代入 $E$ 中：

![0gQ2LQ.png](https://s1.ax1x.com/2020/10/11/0gQ2LQ.png)

#### 预测分析程序的实现

描述语言允许递归调用，为每个非终结符写一个递归子程序

从转换图初态出发，根据射出边：

- 是终结符，匹配，指针前移
- 是非终结符，调用子程序，指针不动
- 两个以上的射出边，使用分支语句

$E$ 的过程：

<img src="https://s1.ax1x.com/2020/10/11/0glZFI.png" alt="0glZFI.png" style="zoom:50%;" />

```c
void procE(void) {
    procT(); 
    if (char == '+') { 
        forward pointer;
        procE(); 
    }
}
```

$F$ 的过程：

<img src="https://s1.ax1x.com/2020/10/11/0gl8Ts.png" alt="0gl8Ts.png" style="zoom:50%;" />

```
void procF(void) {
    if (char == '(') { 
        forward pointer; 
        procE(); 
        if (char == ')') { 
            forward pointer; 
        }; 
        else error(); 
    }; 
    else if (char == 'id') { 
        forward pointer; else error(); }
```



### LL(1) 文法

#### FIRST 集合及其构造

![image-20211017140308511](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211017140308511.png)

对于符号串 $\alpha$，$FIRST(\alpha)$ 是可推导出的**开头终结符集合**。

构造每个文法符号 $X$ 的 $FIRST(X)$：

- 若 $X\in V_T$，则 $FIRST(X)=\{X\}$
- 若 $X\in V_N$，且有 $X\to a\cdots$，$a$ 加入
- 若 $X\to \varepsilon$，$\varepsilon$ 加入
- ==若 $X\to Y\cdots$，把 $FIRST(Y)$ 中所有非 $\varepsilon$ 元素加入==
- ==若 $X\to Y_1\cdots Y_n$，对于某个 $i$，即 $Y_1\cdots Y_{i-1}\Rightarrow^*\varepsilon$，则将 $FIRST(Y_i)$ 所有非 $\varepsilon$ 元素加入==
- ==若 $FIRST(Y_i)$ 均含有 $\varepsilon$，$\varepsilon$ 加入==

技巧：**从有终结符的产生式开始遍历**

#### FOLLOW 集合及其构造

![image-20211017140253205](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211017140253205.png)

$FOLLOW(A)$ 是所有句型中，紧跟 $A$ 之后的终结符或 $\$$ 组成的集合。

若 $S\Rightarrow^*\cdots A$，则规定 $\$\in FOLLOW(A)$。因此 $\$\in FOLLOW(S)$。$\$$ 为输入串的右尾标志

构造每个非终结符 $A$ 的 $FOLLOW(A)$：

- 置 $\$$ 于 $FOLLOW(S)$ 中
- 若 $A\to \alpha B\beta$，则将 $FIRST(\beta)$ 中所有非 $\varepsilon$ 元素加入 $FOLLOW(B)$
- 若 $A\to \alpha B$，或 $A\to\alpha B\beta$ 且 $\beta\Rightarrow^*\varepsilon$，加入 $FOLLOW(A)$ 中所有元素
- 重复直到所有集合不再变化

技巧：**首先找出能推出空的非终结符，反复遍历每个产生式右边的每个终结符**

求 $FIRST,FOLLOW$ 集合（**重点**！！！）：

<img src="https://s1.ax1x.com/2020/10/11/0grK56.png" alt="0grK56.png" style="zoom:50%;" />

#### $LL(1)$ 文法定义

$LL(1)$ 文法 $\iff$ 每个产生式 $A\to \alpha|\beta$ 满足：

- $FIRST(\alpha)\cap FRIST(\beta)=\Phi$
- 若 $\beta\to \varepsilon$，则 $FIRST(\alpha)\cap FOLLOW(A)=\Phi$

#### 判断文法是否为 $LL(1)$ 文法：

<img src="https://s1.ax1x.com/2020/10/11/0gyfvF.png" alt="0gyfvF.png" style="zoom:50%;" />

## 非递归预测分析

**分析表+栈**联合控制

### 预测分析程序的模型及工作过程

决定哪个产生式用于非终结符

模型：

<img src="https://s1.ax1x.com/2020/10/04/0Ggybn.png" alt="0Ggybn.png" style="zoom:50%;" />

输入缓冲区：串后随尾标识符 $

符号栈：存放 $T\cup N$。\$ 先入栈，再将开始符号入栈：\$S

分析表：二维数组 $M[A,a],A\in V_N, a\in V_T \cup \{\$\}$。根据 $A,a$ 在分析表 $M$ 中找产生式

输出流：产生式序列

#### 预测分析控制程序

<img src="https://s1.ax1x.com/2020/10/04/0GjSVP.png" alt="0GjSVP.png" style="zoom:80%;" />

根据栈顶符号 $X$ 和当前输入 $a$：

1. $X=a=\$$：成功
2. $X=a\not=\$$：匹配，栈顶弹出 $X$，指针移动一个位置
3. $X\in V_T,X\not=a$：调用错误处理程序
4. $X\in V_N$，访问分析表 $M[X,a]$：
   - $M[X,a]=X\to Y_1\cdots Y_n$：$X$ 出栈，产生式右部**反序**入栈
   - $M[X,a]=X\to\varepsilon$：弹出 $X$
   - $M[X,a]=error$：调用错误处理程序

**文法 4.4 的预测分析表 $M$，分析输入串 $id+id*id$：**

文法 4.4：

<img src="https://s1.ax1x.com/2020/10/04/0GxN9O.png" alt="0GxN9O.png" style="zoom:80%;" />

预测分析表：

![0GvAJO.png](https://s1.ax1x.com/2020/10/04/0GvAJO.png)

![0GvMwt.png](https://s1.ax1x.com/2020/10/04/0GvMwt.png)

后略。



### 预测分析表的构造

![image-20211017140437317](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211017140437317.png)

若 $A\to \alpha$，$A$ 在栈顶，输入符号 $a\in FIRST(\alpha)$ 时，$M[A,a]$ 放入 $A\to\alpha$。

当 $\alpha\Rightarrow^*\varepsilon$ 时，若输入符号 $b(包括 \$)\in FOLLOW(A)$，$M[A,b]$ 放入 $A\to\alpha$。

给所有无定义的 $M[A,a]$ 标上错误标志

**为下面的文法构造分析表：**

<img src="https://s1.ax1x.com/2020/10/04/0GxgC8.png" alt="0GxgC8.png" style="zoom:40%;" />

### LL(1) 文法

<img src="https://s1.ax1x.com/2020/10/04/0JpBDJ.png" alt="0JpBDJ.png" style="zoom:80%;" />

若文法预测分析表 $M$ 不含多重定义的表项，则为 $LL(1)$ 文法

$LL(1)$ 含义：

- $L$：从左至右扫描输入串
- $L$：最左推导
- $1$：向前看 1 个符号，即当前的输入符号

判断（两个条件等价）：

- 根据文法产生式判断
- 根据分析表判断



### 预测分析方法中的错误处理示例

出错情况及处理：

- $X\in V_T$，但 $X\not=a$：弹出栈顶终结符号
- $X\in V_N$，但 $M[X,a]$ 为空：跳过输入串，直到可继续分析

#### 带有同步化信息的分析表

对于 $A\in V_n,b\in FOLLOW(A)$，若 $M[A,b]$ 为空，加入 “synch”





# 自底向上分析方法

##  短语、直接短语、句柄

### 1 短语

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020060721320120.png)
那么，abp为此句型的短语
总结来说：**一个句型的语法树中任一子树叶结点所组成的符号串都是该句型的短语**，由这概念，那么我们自然可以想到，b也应该是该句型的一个短语。

### 2 直接短语

**跟短语比，限定高度为2的子树。**
如果子树中不再包含其他的子树，即A只能推导出b，而b不能再推出其他的式子，则b为此句型的直接短语。

### 3 句柄

**直接短语中的最左直接短语为该句型的句柄。**

### 4 例子

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020060721364058.png)
如何证明E+T*F是句型呢？最简单的方法就是画抽象语法树，如果能画出对应的抽象语法树，则就表明此表达式是文法的一个句型。

抽象语法树如下:

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200607213655941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgzODc4NQ==,size_16,color_FFFFFF,t_70)
按如上的语法树可知，E+T*F为此文法的一个句型:

```csharp
短语: T*F, E+T*F

直接短语：T*F

句柄：T*F

```

```
S -> a|b|(T) 
T -> TdS|S
证明(Sd(T)db)是S的一个句型，并求出短语，直接短语，句柄
```

此文法的抽象语法树为:

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200607213832752.png)
由此可得S=(Sd(T)db)为此文法的一个句型：

**短语:S，(T)，b，Sd(T)，Sd(T)db，（Sd(T)db)  
直接短语:S，(T)，b
句柄:S** 

## 移入-归约分析(Shift-Reduce Parsing)

![image-20211021190351530](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021190351530.png)

**移入-归约分析器可采取的4种动作**：

**移入**：将下一个输入符号移到栈的顶端

**归约**：被归约的符号串的右端必然处于栈顶。语法分析器在栈中确定这个串的左端，并决定用哪个非终结符来替换这个串

**接收**：宣布语法分析过程成功完成

**报错**：发现一个语法错误，并调用错误恢复子例程

![image-20211021190600109](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021190600109.png)

## LR 分析方法概述

LR文法(Knuth, 1963)是最大的、可以构造出相应移入-归约语法分析器的文法类

L: 对输入进行从左到右的扫描

R: 反向构造出一个最右推导序列

**LR(k)分析**

需要向前查看k个输入符号的LR分析

<u>k= 0 和k= 1 这两种情况具有实践意义</u>

<u>当省略(k)时，表示k=1</u>

### 关于状态

![image-20211021190935485](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021190935485.png)

### LR 分析器（自动机）的总体结构

![image-20211021191016316](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021191016316.png)

### LR 分析表的结构

![image-20211021191118888](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021191118888.png)

分析栈包括符号栈和相应状态栈
分析表包括ACTION表和GOTO表
Ⅰ动作表元素action[Si,aj] 表示当前栈顶状态为S，输入符号为a时所执行的动作。有四种情况：S(移进)，r(归约)，acc(接受)，error(出错)。
Ⅱ状态转换表元素goto[Si,xj] 表示当前栈顶状态为S，文法符号为x时应转入的状态。
所有LR分析器的总控（驱动）程序都一样，区别他们的是分析表。

工作原理：是在总控程序的控制下，从左到右扫描输入符号串，根据分析栈中的状态和文法及当前输入符号，按分析表完成相应的分析工作。

### 活前缀

![image-20211021201032030](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021201032030.png)

### LR分析器的工作过程

![image-20211021193826483](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021193826483.png)



![image-20211021193844890](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021193844890.png)

![image-20211021193857201](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021193857201.png)

### LR 分析算法

* 输入：串w和LR语法分析表，该表描述了文法G的ACTION函数和GOTO函数。

* 输出：如果w在L(G)中，则输出w的自底向上语法分析过程中的归约步骤；否则给出一个错误指示。

* 方法：初始时，语法分析器栈中的内容为初始状态s0，输入缓冲区中的内容为w$。然后，语法分析器执行下面的程序：

  ![image-20211021194110948](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021194110948.png)

## LR(0)分析

### LR(0)项目

![image-20211021194706326](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021194706326.png)

### 增广文法(Augmented Grammar)

![image-20211021194858800](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021194858800.png)

### 文法中的项目

![image-20211021195022012](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021195022012.png)

#### 后继项目（Successive Item）

* 同属于一个产生式的项目，但圆点的位置只相差一个符号，则称后者是前者的后继项目
* A→α· Xβ的后继项目是A→αX·β

#### 项目集闭包

可以把等价的项目组成一个项目集( I ) ，称为项目集闭包(Closure of Item Sets)，每个项目集闭包对应着自动机的一个状态

### LR(0)分析表构造算法

![image-20211021195517275](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021195517275.png)



![image-20211021195729232](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021195729232.png)

![image-20211021195743495](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021195743495.png)

![image-20211021201322026](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021201322026.png)

![image-20211021201335940](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021201335940.png)

![image-20211021201351648](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021201351648.png)

### LR(0) 分析过程中的冲突

![image-20211021201429286](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021201429286.png)

![image-20211021201504841](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021201504841.png)

## SLR分析

首先我们举一个含有冲突的LR(0)分析，如下：

![image-20211021201429286](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021201429286.png)

从上图可以看出，I2和I9存在**移进/归约冲突**。
对于这个冲突，我们可以给出如下的解决方法：

1. 求出E、T的FOLLOW集
2. 若下一个输入符号属于E的FOLLOW集，那么就归约为E
3. 反之则采用移进

![image-20211021204411565](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021204411565.png)

 从FOLLOW集中可以看出，对于I2，当下一个输入符号为 * 的时候， 该 * 不属于E的FOLLOW集合，所以采用**移进**
对于该题SLR分析构造的分析表如下：

![image-20211021204502147](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021204502147.png)



下面给对于任意LR(0)分析存在冲突的**SLR算法**：

![image-20211021204612439](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021204612439.png)

对于一个LR(0)分析存在冲突，我们可以在这个状态（比如例题中的I2）的时候多往后面多看一个字符，对于 该状态中的那种**归约**项目（参考上图），我们需要分析下一个输入字符是否在其式子左边那个字符中的FOLLOW集中。如果在，对于输入该字符就采用归约。对于那种**移进**项目，分析下一个输入字符是否属于圆点后面的那个符号（比如上图中的a1 a2 a3… 就是圆点后面的那个符号），如果属于，就移进。
        总结一下就是，在LR(0)分析的基础之上，再对有语法冲突的状态进行进一步的分析【就是进一步区分到底是移进 还是归约】。这个进一步的分析其实就是看下一个输入字符。利用标准算法进行匹配即可。

### SLR分析表构造算法

只有第三步和LR(0)不同，LR(0)算法中直接无条件归约，SLR要判断

![image-20211021202648986](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021202648986.png)

### SLR文法

定义：如果给定文法的**SLR分析表中不存在有冲突的动作**，那么该文法称为SLR文法

### SLR分析存在的冲突

SLR分析并不可以解决所有的LR(0)分析，可能采用SLR分析后还是会存在语法冲突。如下图：

![image-20211021204809731](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021204809731.png)

对于状态I2，当我们采用SLR分析：当下一个输入符号为 = 的时候，因为 = 属于 R 的FOLLOW集，所以采用**归约操作**；但是我们又发现， **=** 又是S–>L **.** =R 中圆点后的一个字符，按照规则应该采用**移进操作**。
从上面这个例子我们可以看出，**SLR依然是可能存在语法冲突的**。 那么怎么解决呢？为此引入了**LR(1)**分析。

## LR(1)分析

在SLR分析的最后，介绍了SLR依然可能存在语法冲突。为什么呢？
        原因：SLR只是简单地考察下一个输入符号b是否属于与归约项目A→α相关联的FOLLOW(A)，但b∈FOLLOW(A)只是归约α的一个必要条件，而非充分条件
        海轰的理解：如果输入下一个字符是b，我们采用了归约操作，那么就一定可以说明b属于A的FOLLOW集。但是我们不能说：如果b属于A的FOLLOW集，那么就一定可以对A采用归约操作。不好理解的小伙伴可以参考下面的具体实例：
![å¨è¿éæå¥å¾çæè¿°](https://img-blog.csdnimg.cn/20200418135643245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDIyNTE4Mg==,size_16,color_FFFFFF,t_70)

从上图右边生成树可以我们得知，此时 L=R 中的R后面跟着的终结符只能是$,不可能是=，但是R的FOLLOW中却包含了=。

又比如说下一行中的 * R，R下一个终结符只可以是=，不会是 $ 。所以只凭FOLLOW集合判断是否采用归约是不合适。【如果使用FOLLOW   相当于归约的条件放宽了】所以，引入了LR(1)分析，用来解决这种问题。

### 规范的LR(1)项目

将一般形式为[A→α·β, a]的项称为LR(1)项，其中A→αβ是一个产生式，a是一个终结符(这里将$视为一个特殊的终结符)它表示在当前状态下，**A后面必须紧跟的终结符**，称为该项的展望符(lookahead)

* LR(1) 中的1指的是项的第二个分量的长度，也就是：往后多看一个字符
* 在形如**[A→α·β, a]**且**β ≠ ε**的项中，**展望符a没有任何作用**（β中可能含有其他的终结符）
* 但是一个形如**[A→α·, a]**的项在**只有在下一个输入符号等于a时才可以按照A→α 进行归约**：这样的a的集合总是FOLLOW(A)的子集，而且它通常是一个真子集

### 等价LR(1)项目

![image-20211021230928168](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021230928168.png)

### LR(1)自动机

举例说明，文法如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200418143728147.png)
步骤一：分析是否需要使用增广文法，确保最终接收状态只有一个
步骤二：写出FOLLOW集（可以全写 也可以不用 部分也行）
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200418144433882.png)
步骤三：分析初始状态，再根据下个可能输入的符号分析出之后的状态（类似LR(0)分析）
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200418144802533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDIyNTE4Mg==,size_16,color_FFFFFF,t_70)



解释：

![å¨è¿éæå¥å¾çæè¿°](https://img-blog.csdnimg.cn/20200418145257642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDIyNTE4Mg==,size_16,color_FFFFFF,t_70)

由0）可以推导出1式【0):左边橙色框中的式子 1：右边蓝色框中的式子】，有1式中的S是非终结符，所以又可以继续推出等价项目2和3。又2式中圆点后面的L属于非终结符，继续推出4、5式【注意：4、5中的展望符是=，因为2式中L后面有终结符=】然后继续对左边橙色框中的式子进行相同算法的推导即可。
**注1：同一个项目中，若两个或多个式子，只是展望符不同，其他都一样，那么是可以写在一起的，就把展望符合在一起写即可**
**注2：如果除展望符外，两个LR(1)项目集是相同的，则称这两个LR(1)项目集是同心的**

该文法的LR(1)分析表如下：
注：分析表构造方法总体与LR(0)分析表类似。只是在归约的时候，比如对于例子中的I5状态，只有下个输入符为 =/$ 时，才会进行归约。

![image-20211021231317379](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021231317379.png)

### LR分析表构造算法

![image-20211021231409579](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021231409579.png)

### LR(1)文法

定义：如果**LR(1)分析表中没有语法分析动作冲突**，那么给定的文法就称为LR(1)文法

## LALR分析

基本思想：

- 寻找具有相同核心的LR (1) 项集，并将这些项集合并为一个项集。 所谓项集的核心就是其第一分量的集合
- 然后根据合并后得到的项集族构造语法分析表

![å¨è¿éæå¥å¾çæè¿°](https://img-blog.csdnimg.cn/20200418151544530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDIyNTE4Mg==,size_16,color_FFFFFF,t_70)

从上图我们可以发现：I4和I11、I8和I10、I7和I13、I5和I12都是同心的，那么我们就可以将这些同心的项目集合并，形成如下：
注：分析表的方法同LR(1)

![å¨è¿éæå¥å¾çæè¿°](https://img-blog.csdnimg.cn/20200418152131610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDIyNTE4Mg==,size_16,color_FFFFFF,t_70)

### LALR分析冲突

![image-20211021231657489](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021231657489.png)

可见I6和I9是同心项集，但合并后会产生归约-归约冲突

**注1：合并同心项集 不会产生移进- 归约冲突**
**注2：合并同心项集后，虽然不产生冲突，但可能会推迟错误的发现**

### LALR(1)的特点

- 形式上与LR(1)相同
- 大小上与LR(0)/SLR相当
- 分析能力介于SLR和LR(1)二者之间：SLR<LALR(1)<LR(1)
- 合并后的展望符集合仍为FOLLOW集的子集

### LALR文法

定义：如果分析表中没有语法分析动作冲突，给定的文法就称为LALR (1) 文法，就可以根据该分析表进行语法分析

## LR分析中的错误处理

![image-20211021232014066](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021232014066.png)



![image-20211021232029969](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021232029969.png)

![image-20211021232041462](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211021232041462.png)



## LR文法的判断

![image-20211027165041322](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211027165041322.png)

![image-20211027165110606](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211027165110606.png)

![image-20211027165134742](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211027165134742.png)

（1）写拓广文法

![image-20211027165155752](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20211027165155752.png)

# 软件工具 YACC